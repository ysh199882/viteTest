var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/index.ts
import { resolve } from "path";
import { ESLint } from "eslint";
import { createFilter } from "@rollup/pluginutils";

// package.json
var name = "vite-plugin-eslint";

// src/utils.ts
function parseRequest(id) {
  return id.split("?", 2)[0];
}
function pickESLintOptions(options) {
  const _a = options, {
    include,
    exclude,
    formatter,
    emitWarning,
    emitError,
    failOnWarning,
    failOnError,
    throwOnError,
    throwOnWarning
  } = _a, eslintOptions = __objRest(_a, [
    "include",
    "exclude",
    "formatter",
    "emitWarning",
    "emitError",
    "failOnWarning",
    "failOnError",
    "throwOnError",
    "throwOnWarning"
  ]);
  return eslintOptions;
}

// src/index.ts
function eslintPlugin(rawOptions = {}) {
  let eslint;
  let filter;
  let formatter;
  let options;
  const pathCache = /* @__PURE__ */ new Set();
  return {
    name,
    async configResolved(config) {
      options = Object.assign({
        include: /\.(jsx?|tsx?|vue|svelte)$/,
        exclude: /node_modules/,
        cacheLocation: resolve(config.cacheDir, ".eslintcache"),
        formatter: "stylish",
        emitWarning: true,
        emitError: true,
        failOnWarning: false,
        failOnError: true,
        throwOnWarning: false,
        throwOnError: false
      }, rawOptions);
      const eslintOptions = pickESLintOptions(options);
      filter = createFilter(options.include, options.exclude);
      eslint = new ESLint(eslintOptions);
      switch (typeof options.formatter) {
        case "string":
          formatter = (await eslint.loadFormatter(options.formatter)).format;
          break;
        case "function":
          formatter = options.formatter;
        default:
          break;
      }
    },
    async transform(_, id) {
      const filePath = parseRequest(id);
      if (!filter(filePath) || await eslint.isPathIgnored(filePath)) {
        return null;
      }
      if (options.cache) {
        pathCache.add(filePath);
      }
      const report = await eslint.lintFiles(options.cache ? Array.from(pathCache) : filePath);
      const hasWarning = report.some((item) => item.warningCount > 0);
      const hasError = report.some((item) => item.errorCount > 0);
      const result = formatter(report);
      if (options.fix && report) {
        ESLint.outputFixes(report);
      }
      if (hasWarning && (options.emitWarning || options.throwOnWarning)) {
        const warning = typeof result === "string" ? result : await result;
        if (options.failOnWarning) {
          this.error(warning);
        } else {
          this.warn(warning);
        }
      }
      if (hasError && (options.emitError || options.throwOnError)) {
        const error = typeof result === "string" ? result : await result;
        if (options.failOnError) {
          this.error(error);
        } else {
          console.log(error);
        }
      }
      return null;
    }
  };
}
export {
  eslintPlugin as default
};
